// STRIPE/PAYMENT REMOVED - Commented out for cleanup
/*
import Stripe from 'stripe';
import { config } from '../config/env';

// Initialize Stripe (only if key is provided)
let stripe: Stripe | null = null;
if (config.stripeSecretKey) {
  stripe = new Stripe(config.stripeSecretKey, {
    apiVersion: '2025-11-17.clover',
  });
}

export interface PaymentSessionData {
  planId: string;
  planName: string;
  price: number;
  currency: string;
  customerEmail?: string;
}

export interface PaymentSession {
  id: string;
  sessionId: string;
  planId: string;
  status: 'pending' | 'completed' | 'failed';
  createdAt: Date;
  completedAt?: Date;
}

// In-memory storage for payment sessions (in production, use database)
const paymentSessions = new Map<string, PaymentSession>();

export const paymentService = {
  /**
   * Create a Stripe checkout session
   */
  async createCheckoutSession(data: PaymentSessionData): Promise<{ sessionId: string; url: string }> {
    try {
      if (!stripe) {
        // Development mode: return mock session
        const mockSessionId = `mock_${Date.now()}`;
        return {
          sessionId: mockSessionId,
          url: `${config.frontendUrl}/payment-success?session_id=${mockSessionId}`,
        };
      }

      const session = await stripe.checkout.sessions.create({
        payment_method_types: ['card'],
        line_items: [
          {
            price_data: {
              currency: data.currency || 'chf',
              product_data: {
                name: `${data.planName} Plan`,
                description: `AIDevelo.ai ${data.planName} Subscription`,
              },
              unit_amount: data.price * 100, // Convert to cents
              recurring: {
                interval: 'month',
              },
            },
            quantity: 1,
          },
        ],
        mode: 'subscription',
        success_url: `${process.env.FRONTEND_URL || 'http://localhost:5173'}/payment-success?session_id={CHECKOUT_SESSION_ID}`,
        cancel_url: `${process.env.FRONTEND_URL || 'http://localhost:5173'}/checkout?planId=${data.planId}&canceled=true`,
        customer_email: data.customerEmail,
        metadata: {
          planId: data.planId,
          planName: data.planName,
        },
      });

      // Store session
      const paymentSession: PaymentSession = {
        id: session.id,
        sessionId: session.id,
        planId: data.planId,
        status: 'pending',
        createdAt: new Date(),
      };
      paymentSessions.set(session.id, paymentSession);

      return {
        sessionId: session.id,
        url: session.url || '',
      };
    } catch (error) {
      console.error('[PaymentService] Error creating checkout session:', error);
      throw new Error('Failed to create checkout session');
    }
  },

  /**
   * Retrieve a Stripe checkout session
   */
  async getCheckoutSession(sessionId: string): Promise<Stripe.Checkout.Session | null> {
    try {
      if (!stripe) {
        // Development mode: return mock session
        // Create a minimal mock that satisfies the Stripe.Checkout.Session type
        const mockSession: Partial<Stripe.Checkout.Session> = {
          id: sessionId,
          object: 'checkout.session',
          payment_status: 'paid',
          status: 'complete',
          metadata: { planId: 'business', planName: 'Business' },
          customer_email: 'test@example.com',
          mode: 'subscription',
          created: Math.floor(Date.now() / 1000),
        };
        return mockSession as Stripe.Checkout.Session;
      }

      const session = await stripe.checkout.sessions.retrieve(sessionId);
      return session;
    } catch (error) {
      console.error('[PaymentService] Error retrieving session:', error);
      return null;
    }
  },

  /**
   * Handle webhook event from Stripe
   */
  async handleWebhookEvent(event: Stripe.Event): Promise<void> {
    switch (event.type) {
      case 'checkout.session.completed': {
        const session = event.data.object as Stripe.Checkout.Session;
        const paymentSession = paymentSessions.get(session.id);
        if (paymentSession) {
          paymentSession.status = 'completed';
          paymentSession.completedAt = new Date();
          paymentSessions.set(session.id, paymentSession);
        }
        break;
      }
      case 'checkout.session.async_payment_failed': {
        const session = event.data.object as Stripe.Checkout.Session;
        const paymentSession = paymentSessions.get(session.id);
        if (paymentSession) {
          paymentSession.status = 'failed';
          paymentSessions.set(session.id, paymentSession);
        }
        break;
      }
      default:
        console.log(`[PaymentService] Unhandled event type: ${event.type}`);
    }
  },

  /**
   * Get payment session by ID
   */
  getPaymentSession(sessionId: string): PaymentSession | undefined {
    return paymentSessions.get(sessionId);
  },

  /**
   * Get purchase ID from session (for linking to onboarding)
   */
  getPurchaseId(sessionId: string): string {
    // In production, this would be stored in database
    // For now, we use the session ID as purchase ID
    return sessionId;
  },
};
*/

